<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>06-08</title>
    <url>/2020/06/08/06-08/</url>
    <content><![CDATA[<h1 id="随随便便"><a href="#随随便便" class="headerlink" title="随随便便"></a>随随便便</h1><h3 id="comp9101-assignrmnt1"><a href="#comp9101-assignrmnt1" class="headerlink" title="comp9101-assignrmnt1"></a>comp9101-assignrmnt1</h3><p>&emsp; 又颓废了两天，今天正好也是周一，恢复正常吧<br>comp9101的assignemtn1有点小难啊，还有给了hints，再结合网上查阅的资料，总算完成了大部分。自我感觉算法这一块需要好好补一补缺漏了。这个assignemnt用到了多次排序算法的分析，还有分治的思路。最蛋疼的还是数学吧，求导换底之类的都忘的差不多了，不过本身水平也不咋地…………<br>&emsp; 然后就是latex，不得不说自从上学期多次使用之后已经爱上了这个东西，word，算个捷豹！latex写公式和伪代码是真的舒服，看起来也很舒爽。不过写blog用的是markdown，有时候容易记混了，导致自己觉得写出来了，但是渲染不出来…………</p>
<h3 id="comp9900"><a href="#comp9900" class="headerlink" title="comp9900"></a>comp9900</h3><p>&emsp; 这周就得把proposal的核心内容搞出来，像system flow之类的，下周再扣扣细节就交了。之后就是代码实现了，希望自己的表现不要太糟糕。</p>
<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p>&emsp; 以后关于算法题的内容我应该都会叫leetcode吧，简单直接。其实周末还是默默增增的看了俩题的，不过都是简单的题，接下来就得好好对待一下了，认真分析题目，尝试 free-bug…………就当在想peach吧，分析题目这个真的很重要，每次看待讨论区的大神们真的惊呼卧槽！尤其是上次那道贪心算法的题，大神分析过后就感觉简单的一匹！</p>
<p><strong>着眼当下，踏实前进！</strong></p>
]]></content>
      <tags>
        <tag>--杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-hexo</title>
    <url>/2020/06/05/hello-hexo/</url>
    <content><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p>&emsp;重新用hexo搭建了一个个人blog，感觉就清爽很多!</p>
<h3 id="by-the-way："><a href="#by-the-way：" class="headerlink" title="by the way："></a>by the way：</h3><p>把老的blog删掉的时候忘了备份了…………还好没写几天，后面把内容再补上吧</p>
]]></content>
      <tags>
        <tag>--life</tag>
      </tags>
  </entry>
  <entry>
    <title>ER图</title>
    <url>/2020/06/08/ER%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="数据库之ER图"><a href="#数据库之ER图" class="headerlink" title="数据库之ER图"></a>数据库之ER图</h1><blockquote>
<p>前言：proposal需要做一个ER图，也算是对后端model建模的一个前期准备吧。顺便回顾一ER图的相关知识。</p>
</blockquote>
<p>ER图分为实体、属性、关系三个核心部分。实体是长方形的体现，而属性则是椭圆形，关系为棱形。</p>
<ul>
<li><p>ER图的实体（Entity）</p>
<blockquote>
<p>实体是数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体中包括张三、李四等等，实体成员（entity member）/实体实例（entity instance）不需要出现在ER图中。</p>
</blockquote>
</li>
<li><p>ER图的属性（attribute）</p>
<blockquote>
<p>属性是数据对象所具有的属性，例如学生实体，具有姓名、性别、年龄、学号等属性，用椭圆形表示。属性分为唯一属性（unique attribute）和 非唯一属性，唯一属性是指唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p>
</blockquote>
</li>
<li><p>ER图的关系（relationship）</p>
<blockquote>
<p>关系用来表现数据对象与数据对象之间的联系，例如学生的实体与成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。</p>
</blockquote>
</li>
</ul>
<p>ER图中关联关系有三种：</p>
<p>1.一对一（one to one）：</p>
<blockquote>
<p>一对一关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体B中的每个实体至多与实体集A中一个实体有关系。</p>
</blockquote>
<p>2.一对多（one to many）：</p>
<blockquote>
<p>一对多关系是指实体集合A与实体集合B中至少有N个（N&gt;0）个实体有关系；并且实体集合B中每一个实体至多与实体集合A中一个实体有关系。</p>
</blockquote>
<p>3.多对多（many to many）：</p>
<blockquote>
<p>多对多关系是指实体集合A中的每一个实体与实体集合B中至少有M(M&gt;0)个实体有关系，并且实体集合B中的每一个实体与实体集合A中的至少N(N&gt;0)个实体有关系。</p>
</blockquote>
]]></content>
      <tags>
        <tag>--数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/06/07/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>&emsp; 之前零零碎碎做过一些题，但是没有系统的整理过，通过这个blog，系统的整理并且记录一下吧</p>
<h3 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h3><ul>
<li>难度：简单<br>描述 ：操作给定的二叉树，将其变换为源二叉树的镜像。<br>二叉树的镜像定义：<br>源二叉树：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    8</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  6   10</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">5  7 9 11</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>镜像二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    8</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  10   6</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">11 9 7  5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val &#x3D; 0;</span><br><span class="line">    TreeNode left &#x3D; null;</span><br><span class="line">    TreeNode right &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class solution&#123;</span><br><span class="line">	public void Mirror(TreeNode root)&#123;</span><br><span class="line">		if(root!&#x3D;null)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(root.left!&#x3D;null &amp;&amp; root.right!&#x3D;null)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode tempnode&#x3D;root.left;</span><br><span class="line">		root.left&#x3D;root.right;</span><br><span class="line">		root.right&#x3D;tempnode;</span><br><span class="line">		if(root.left!&#x3D;null)&#123;</span><br><span class="line">			Mirror(root.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if(root.right!&#x3D;null)&#123;</span><br><span class="line">			Mirror(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路：简单的一道题，首先判断一下root是否为空，root的左右子节点是否为空，为空就直接返回。接下来就是经典的值的交换，用一个tempnode来转接，之后在判断左右节点，如果有就递归，将左节点或右节点传入。</p>
<h3 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h3><p>题目：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays</span><br><span class="line"></span><br><span class="line">public class Solution&#123;</span><br><span class="line">	public boolean  isCountinues(int [] numbers)&#123;</span><br><span class="line">		int Cardzero&#x3D;0;</span><br><span class="line">		int Carddiff&#x3D;0;</span><br><span class="line">		int length&#x3D;numbers.lenght;</span><br><span class="line">		if(length&#x3D;&#x3D;0)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;length-1;i++&gt;)&#123;</span><br><span class="line">			if(numbers[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">				Cardsero+&#x3D;1;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(numbers[i]&#x3D;&#x3D;numbers[i+1])&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			Carddiff+&#x3D;numbers[i+1]-numbers[i]-1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(Cardzero&gt;&#x3D;Cardiff)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路分析： （1）首先就是排序，这里是调用的Arrays,可以直接用sort来排序<br>        （2）查看大小王数量，也即是0的数量<br>        （3）统计五张牌里有没有对子，一旦有重复的牌，就不可能是顺子里<br>        （4）统计五张牌得差值，顺子因该是五张连续的牌，最大值和最小值之间<br>            的差不能大于5. 这里关于差值的思路是这样的，连续的牌认为没有差值，因为大小王可以当作任何牌，所以非0的牌两张相隔的牌可以差大于1，因为0可以代替中间缺的那张。<br>            例如：{0,1,2,4,5},0可以代替3。</p>
]]></content>
      <tags>
        <tag>--code</tag>
      </tags>
  </entry>
</search>
